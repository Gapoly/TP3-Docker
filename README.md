# TP3-Docker

Dans ce TP, je vais expliquer les technos que j'ai mis en place pour r√©pondre √† la probl√©matique et comment je les ai appliqu√©s.

Avant de commencer, je vais remettre en √©vidence la probl√©matique impos√© par l'exercice :

## Probl√©matique

> Partant d'une application 3-tiers existante : un frontend en VueJs, un backend en Python-Flask/FastAPI, une base de donn√©es Postgres, il va falloir mettre en place trois conteneurs interagissant entre eux d'une part et manipulant des donn√©es de mani√®re p√©renne : le code source des applications et les donn√©es de la base de donn√©es. Cette solution sera d√©ploy√©e dans un r√©seau d√©di√©, afin de ne pas lui permettre d'interagir avec d'autres conteneurs (et par r√©ciproque, de ne pas se faire attaquer, ou le moins possible, depuis l'ext√©rieur).

L'exercice √† √©tait s√©par√© en 4 √©tapes, qui sont :

- **Le r√©seau**
- **Les volumes**
- **Les ports**
- **Les variables d'environnement**

### üì∂ Le r√©seau

> Nous devons d√©ployer 3 conteneurs chacun dans son r√©seau. Un frontend, un backend et une base de donn√©es. Le frontend communique avec le backend et le backend communique avec la base de donn√©es. Le client se connecte juste au frontend.



### üß≥ Les volumes

> Pour un g√©rer la disponibilit√© des donn√©es au cas o√π que les conteneurs ne marche plus. Il faut savoir g√©rer les volumes pour mettre en place un syst√®me de continuit√©. Pour cela, on va mettre en place des volumes sur l'h√¥te Docker. Si le conteneur tombe, Docker pourra relancer le fichier *.yml sans perte donn√©es, car elles sont sur l'h√¥te.

### üõ•Ô∏è Les ports

> Bien √©videmment, il faudra ouvrir les ports sur les conteneurs pour qu'elles puissent communiqu√©s entre elles :

- **MySQL : 3306**
- **HTTP : 80**

> J'ai mis en valeur les 2 ports principaux qui seront utilis√©s mais bien √©videmment il en faudra plus.

### üõ§Ô∏è Les variables d'environnement

> Les variables d'environnement permette de pouvoir automatiser le plus possibble le d√©ploiement des conteneurs. Chaque conteneurs propose des variables propre √† lui m√™me. Il faudra lire la doc pour les connaitre et savoir lesquels doivent √™tre appliqu√©s.


# 0. Mes Technos

De base, il √©tai demand√© d'utiliser VueJs en frontend, Python-Flask/FastAPI en backend et Postgres en base de donn√©es. Etant donn√© que je suis sp√©cialis√© syst√®mes & r√©seaux, je ne maitrise ni le Python, ni le VueJs. Je ne pouvais pas partir sur ces technos. De m√™me pour le postgres, je ne connais pas.

Pour palier √† ce probl√®me, tout en respectant l'exercice j'ai choisie d'autres technos.

## 0.1 Wordpress

<img hspace="20" align="left" src="https://pngimg.com/uploads/wordpress/wordpress_PNG47.png" alt="Logo Wordpress" width="100"/>

Wordpress est logiciel qui permet de cr√©er des sites web. Dans notre cas, il r√©pond parfaitement au besoin du backend. Un logiciel qui a besoin d'un acc√®s √† une base de donn√©es, mais on ne veut pas que le client se connecte directement dessus. Evidemment, on ne mettra pas en place de site web, mais il faudra faire en sorte que le Wordpress se connecte √† la BDD et que le frontend le redirige bien sur le Wordpress.

- **R√©seau :** backend
- **Volumes :** wordpress:/var/www/html
- **Ports :** HTTP 8800:80
 
## 0.2 MySQL

<img hspace="20" align="left" src="https://pngimg.com/uploads/mysql/mysql_PNG23.png" alt="Logo Wordpress" height="100"/>

Pour la base de donn√©es, je suis rest√© sur technologie classique et connue qui est MySQL. Pas besoin de pr√©sentation dessus. J'ai choisie cette techno car sur le peux de base de donn√©es que j'ai pu touch√©, cela fut toujours MySQL ou MariaDB. Elle sera suffisante pour la partie base de donn√©es.

- **R√©seau :** bdd
- **Volumes :** mysql:/var/lib/mysql
- **Ports :** MySQL 3306:3306


## 0.3 Nginx Proxy Manager

<img hspace="20" align="left" src="https://nginxproxymanager.com/icon.png" alt="Logo Wordpress" height="100"/>

Nginx Proxy Manager (NPM) est un proxy inverse dot√© d'une interface web pour g√©rer facilement les param√©trage du serveur. Il propose de configurer et d'administrer des proxys inverses, des certificats TLS, et des redirections de sites web. Cette techno rentrera parfaitement dans le r√¥le de frontend.

<br>

- **R√©seau :** frontend
- **Volumes :** /docker/nginx/data:/data - /docker/nginx/letsencrypt:/etc/letsencrypt
- **Ports :** Interface HTTP 8181:81 - Redirection HTTP 8008:80 - Redirection HTTPS 4443:443

## 0.4 Finalit√©

Pour reprendre vite fait les technos utilis√©s. Nous aurons un NPM qui fera office de frontend pour rediriger le traffic vers le Wordpress, qui √† son tour se connectera √† MySQL qui h√©bergera la base de donn√©es.

L'arborescence final ressemblera √† cela :

```
‚îî‚îÄ‚îÄ H√¥te Docker
    ‚îú‚îÄ‚îÄ Nginx Proxy Manager
    ‚îú‚îÄ‚îÄ Wordpress
    ‚îî‚îÄ‚îÄ MySQL
```

# üì∂ 1. Le r√©seau

Comme dit pr√©cedemment, le r√©seau sera coup√© en trois pour chaque service. Le frontnet qui fera office de frontend, le backnet qui fera office de backend le bdd pour la base de don√©es.

- **Wordpress :** frontnet, backnet, bdd
- **NPM :** frontnet
- **MySQL :** bdd

